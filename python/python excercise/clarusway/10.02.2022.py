# -*- coding: utf-8 -*-
"""10 şubat 2022.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1aj1NCNX-mf0bQCEohAle5alVBfy4-gfR

# DİCTİONARY AND SETLER
"""

dict_by_dict = {'animal': 'dog',
                'planet': 'Neptun',
                'number': 40,
                'pi': 3.14,
                'is_good': True}
print(dict_by_dict.items(), '\n')
print(dict_by_dict.keys(), '\n')
print(dict_by_dict.values(), '\n')

"""bu kod blokları bize 3 temel fonksiyonu gösteriyor bize. items metodu (fonksiyonu) herhangi bir objectin üzerine kurulan fonksiyonlara metod deniyor.
**print()tek başına bir fonksiyon. içine bir argüman gönderdiğimizde bize özel bir hizmet yapıyor. **yani anlamlı ve faydalı olan kod bloklarına FONKSİYON denir.
# len()bir fonksiyon içine iterable, bir arguman gönderiyoruz, o bize eleman sayısını döndürüyor.
**burada dictionary nin bir fonksiyonu olan item, bir objectin fonksiyonudur. bir objecte bağlı fonksiyonlara metod denir.
string in fonksiyonları? string.upper, string.lower, string.replace ... bunlar stringe bağlı fonksiyonlardan bazıları. bunlar bir string üzerinden işlem görürler. bunlara da method deniyor.
list in fonksiyonları ? list.append(), list.count() bunlarda list in bir methoduydu mesela.
*** buradada mantık aynı dictionary methodları da; items, keys, values, clear, copy, fromkeys, get ...
bir şeye tanımlı fonksiyonları görmek için örnek dict. fonk. görmek için bir dict tanımlayıp (dict_by_dict.) noktaya basınca ona dair fonksiyonları görürüz.
"""

dict_by_dict.items() #bize key ve value ları getirir. hepsini tuple olarak ayırarak getirir.

x, y = dict_by_dict.items() #tek bir value yu iki tane değişkene atayamıyoruz. hata veriyor aşağıda görüldüğü gibi.

dict_by_dict.items() #bu bir iterable dır yani elemanlarına bölünebilir. bunu list fonk. içine koyabiliriz. döndürdüğü şey bir list olacak.
list(dict_by_dict.items()) #list fonksiyonu iterable alır. Çıkan sonuç liste içinde ama tuple tuple oldu. her keys, value (5 tane) bir tuple oldu.

items = list(dict_by_dict.items()) #bunu bir değişkene atadık.

x, y = items[0] #burada items 0 deyince buradaki listin ilk elemanını indexlemiş oluruz(x=keys e denk gelir, y ise value ya.)
print(x) #buradaki items 0 aslında bir tuple oluyor. iki değişkeni iki value ya atamış olduk, x,y = keys, value

print(x, y)

x, y = items[0] #bu aslında aynı zamanda x, y = "animal", "dog" şeklinde bir değişken atama şekli oluyor.

dict_by_dict.keys() #burada sadece keysleri verecek.

tuple(dict_by_dict.keys()) #dictionary key leri artık bir tuple oldu.

dict_by_dict.values() #burada da value ları çağırmış olduk.

set(dict_by_dict.values()) #value ları set fonksiyonu kullarak kümelere yani setlere çevirdik.

family = {'name1': 'Oray',
          'name2': 'Asuman',
          'name3': 'Enes',
          'name4': 'Enesimin Kardeşi'
          }
print(family)

list(family.items()) #tuple tuple ayırır.(liste haline getirdik)

list(family.keys())  #liste haline getirdik.

list(family.values()) #liste haline getirdik.

family["name5"] = 'ikinci Kardeş' #burada family in içine İNDEXLEME METODU ile yeni bir eleman ekledim.
#dictionary leri key ler üzerinden indexleriz. burada key üzerinden yeni eleman eklemiş olduk.

print(family)

#update metodu ile tek bir dictionary gönderebiliriz, yani süslü paranteze alarak yeni elemanı atarız mevcut dictionary içine.
family.update({"name6" : "üçüncü kardeş" })

print(family)

"""### mevcut keys lere yeni değer atama 1.yöntem. update metodu."""

#mevcuttaki keys güncelleme. name 2 asuman iken asu olarak değiştirmiş olduk. yani buradada value değiştirmiş olduk. 
family.update({'name2': 'Asu'})
print(family)

"""## **mevcut keys lere yeni değer atama 2.yöntem. DİREKT ATAMA**


"""

family["name5"] = 'ikinci Kardeş Kız Olabilir' #mevcut bir keys e = ile yeni bir değer atayalım.
print(family)

#DEL YÖNTEMİ İLE KEY SİLME
#DEL BİR FONKSİYON DEĞİL KEYWORD dür, boşluk bırakıp karışına yazılanı siler.
#dictionary ler iterable dır, tuple lar mutable dır. tuple değişmez yani.
del family["name1"]
print(family)
#hata verir.

del family["name3"], family["name5"] #birden fazla da eleman silebiliriz. burada indexleme yaparak silme işlemini gerçekleştirmiş olduk. Arada virgül kullanarak eleman ekleriz.

family

a = "clarusway"
a

del a  #atadığımız şeyleri bellekte yer kaplamasın diye silebiliriz, şuan burada a sildik, print(a) deyince öyle bir veri yok diyor.
#kullanmasakda olur ama silmekteki maksat yer işgal etmesini engellemektir.

print(a)

#keyword lerden biri olan in true ya da false output verir.bu bir kontrol metodudur. örnek clarusway içinde i varmı, a varmı.
"i" in "clarusway"

"a" in "clarusway"

"A" in "clarusway"

#KOLAY LİSTE YAPMA METODU.
bootcamp = "c l a r u s w a y".split() #burada bir şey belirtmediğimiz için space lerden böler.
bootcamp

new = "ali-deli-veli " #burada parametreyi değiştirdik, - görünce böl, her biri virgülle ayır list e yap.
#tire (-) den böl ve bölmüş olduğun her string parçasını listenin elemanları haline getir.
new.split("-")

"a" in bootcamp

#dictionary ler bir iterable
dict_by_dict

"dog" in dict_by_dict #dog dict. içerisinde var mı, yok mu diye sorduk. yanıt false ÇÜNKÜ İN METODU KEYS LERE BAKAR, VALUE BAKMAZ.

"planet" in dict_by_dict

#value ise nokta kullanarak bakarız.
"dog" in dict_by_dict.values()

#not in nasıl kullanılır. in ve not in ters çalışır. içinde yok değil mi evet(true) yok.
# dog dict_by_dict içinde yok mu? evet yok.
"dog" not in dict_by_dict

"""# **NESTED DİCTS (İÇ İÇE DİCTİONARY)**"""

school_records = {
    "personal_info":
    {"kid": {"tom": {"class": "intermediate", "age": 10},
             "sue": {"class": "elementery", "age": 8}
             },
     "teen": {"joseph": {"class": "collage", "age": 19},
              "marry": {"class": "high school", "age": 16}
              },
     },
     "grades_info":
     {"kid": {"tom": {"math": 88, "speech": 69},
              "sue": {"math": 90, "speech": 81}
              },
      "teen": {"joseph": {"math": 88, "speech": 69},
               "sue":{"math": 90, "speech": 81}
               },
      },
}

#personel_info ve grades_info bir keys  (bu nedenle bunun uzunluğu yani len 2 dir.)
#karşısında bulunanların tamamı ise bir value dur.
#iki tane key iki tane item demektir, bu durumda eleman sayısı 2 dir.

len(school_records)

school_records["personal_info"]  #personal info = key, çıktı ise personal info nun value su gelir.

type(school_records["personal_info"]) #bu bir dict.

len(school_records["personal_info"]) #bununda içinde 2 elemanı var. kid ve teen burada key dir, karşısındakilerde yine value dur. 2tane dictionary var.

school_records["grades_info"] #diğer key i indexledik. sonuç olarak bir tane daha dictionary çıkmış oldu.
#yani BURADA VALUE lar DİCTİONARY oluyor. KEYS, DİCTİONARY OLMAZ HATA VERİR.
#KEYS dictionary, list olamaz hata verir ama value lar dictionary olabilir.

#yukarda "grades_info" and "personal_info" bu key ler bir STRİNG dir.
#value lari ise dictionary dir.
#grades info dictionary sinin key leri ise kid ve teen dir onlarda string dir, value ları ise dictionary dir.
#dictionary ler indexlenebildiği için inedexleme iç içe devam edilebilir. alttaki örnek.

school_records["personal_info"]["kid"] #indexlemeye devam edince kid (key) karşısındaki dict.(value) döndürdü.
#bu bir dict. döndürdüğüne göre indexlemeye devam edebiliriz, bu kez de tom(key) indexleyelim.

len(school_records["personal_info"]["kid"])

school_records["personal_info"]["kid"]["tom"] #tom > key dir. output ise tom un > value dur.
#çıktı bir dictionary olduğuna göre indexlemeye devam edebiliriz. bu kez de age (key) indexleyelim.

len(school_records["personal_info"]["kid"]["tom"])

school_records["personal_info"]["kid"]["tom"]["age"] #matruşka bebekler gibi içten içe devam ediyor. burada "age" yine key oluyor, output ise integer dır.
#burada artık indexleme son bulur, çünkü artık dictionary bitti, integer döndürdü bize age key i.

print(school_records["personal_info"]["teen"]["marry"]["age"])

print(school_records["grades_info"]["teen"]["joseph"]) #burada bir dict. döndü.

print(list(school_records["grades_info"]["teen"]["joseph"].items()))

"""# *THE MOST FREQUENT ELEMENT*
EN SIK GÖRÜLEN ELEMAN.
ASSİGMENT DAN QUESTİONS ANSWERS
"""

#Burada en çok tekrar eden elemanı bulunuz. 
# en çok bulunan elemanı bulacağız 1, (max)
#en çok tekrar edeni bulacağız 2. (count) yani bize 2 fonksiyon lazım.
numbers = [-1, 3, 7, 4, 3, 0, 3, 16, 3, 7, 0, 0, 1]

max(numbers) #içine iterable bir değer koyunca en büyüğünü veriyormuş.

max(2, 3, 5)

max("ali", "veli", "deli") #burada da alfabetik olarak en büyüğü aldı. veli yi döndürdü.
max("a", "z", "j") #burada da z yi döndürdü.

empty = [] #en kolay iterable tanımlama yöntemi, boş list tanımlamaktır. 
max(empty, default = "Boş") #bu max fonk. özelliği, burada iterable boş ise default ne atarsan onu döndürür. dolu ise iterable içinden seçim yapar.

new_line = [1, 2, 3] #mesela burada list boş değil içinde elemanlar olduğu için default yazılanı döndürmedi, list in içindeki en büyük elemanı döndürdü.
max(new_line, default = "asuman")

sequence = [1, 1, 1, 1, 2, 2, 2, 3, 3, 4]
max(sequence)

sequence.count(4) #sorulan elemanın kaç kez tekrar ettiğini veriyor count() fonksiyonu.

sequence.count(1)

max(numbers)  #max ile en büyük elemanı yakalıyoruz.

numbers.count(16) #burada da en büyük olan elemanın kaç kez tekrar ettiğini bulduk, count fonksiyonu ile.

numbers.count(max(numbers)) #bu şekilde yazarsak en büyük sayının kaç kez tekrar ettiğini tek satırda alırız.

print(len([[1, 2, 3]][0])) # listenin yanında bir köşeli parantez daha varsa bu indexlemedir, yani [0] ile listenin içine girdik.

max(numbers, key = numbers.count) #key fonksiyonuna hiçbir şey atamazsak en büyüğünü verir ama atama yaparsak bizim istediğimizi verir.
#burada diyoruz sen bu numbers.count un iterable in tüm elemanlarına tek tek uygula ve sonra en büyüğünü al diyoruz aslında.
#mesela -1 gitti baktı bir tane var, 3 giti baktı 4 tane var... hepsini tek tek baktı hafıza aldı, bunlardan en çok tekrar edenlerden yani en büyüğünü aldı.
#burada aldığı (1, 4, 2, 4, 4, ....) yani hangisinden kaç tane olduğu da bir iterable bir sonuç alırız. bunlar arasından en çok tekrar eden en büyüğü aldı.

numbers.count(max(numbers, key = numbers.count)) #en çok tekrar edenler içinden en büyüğü 3 dü tekrar sayısı da 4 oluyor.

sehirler = ["istanbul", "van", "ağrı", "ankara"]

sorted (sehirler) #bu stringleri baş harflerine göre sıralar. #BURADA LİSTELER KALICI OLARAK DEĞİŞMEDİ SADECE SIRALAMA YAPILDI AMA SORT DA EN ALTTA KALICI OLARAK DEĞİŞTİ.

#ama biz mesela bu stringleri uzunluklarına göre sıralamak istesek sorted()fonksiyonunun dna sıyla oynamamız gerekiyor.
sorted(sehirler, key = len) #bu iterable ı (van 3, ağrı 4, ankara 6, istanbul 7) yani sen fonksiyonun ürettiği sonucu 3 4 6 7 yi sırala.

sorted(sehirler, key = len, reverse = True) #büyükten küçüğe doğru yani tersten sıralatmak içinse reverse = False iken True yaptık ve sıralama yönünü değiştirmiş olduk.

sehirler.sort(key = len) #burada da key var. burada şehirler listesi sort fonksiyonu ile kalıcı olarak değişiyor. key, reverse bunlar bir parametredir.
print(sehirler) #LİST LER MUTABLE OLDUĞU İÇİN YAPTIĞIMIZ BİR OPERASYON KALICI OLARAK DEĞİŞİKLİK YAPAR.