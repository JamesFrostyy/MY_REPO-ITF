# -*- coding: utf-8 -*-
"""03.03.2022.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1q12CAlRcJRfN2d7A5JPRdvmvi-ghwTmd
"""

course = "clarusway"
counter = 0
for i in course :
    counter += 1
    i += '_'
    print(i, end="")

course = "clarusway"
counter = 0
for i in course :
    counter += 1
    i += '_'
    print(i)

course = "clarusway"
for i in course :
    print(i)

"""# ***for döngüsünün DİCTİONARY KULLANIMINDAKİ çeşitli yazımları.***
1)İTERATE ETTİĞİMİZDE KEY LERİ ALDIĞINI
2)VALUE LARI ALMAK İSTEDİĞİMİZDE VALUEOBJECT ALDIĞINI GÖRDÜK
3)HER İKİSİNİDE ALMAMAZI GEREKTİĞİNDE İSE EĞER ÇİFT YAPILI BİRŞEYSE TUPLE GİBİ İKİ DEĞİŞKEN KULLANABİLİRİZ.(BKNZ:THİRD) KEY, VALUE GİBİ İKİ DEĞİŞKEN(örnekte öyle yazdığımız için YOKSA Kİ a,b de deriz.)
burada istediğimiz değişken ismini verebiliriz, asıl mesele buradaki iterable objectinin karakteridir.(örnekteki user.items() kısmı)
buradaki iterable karaketeri nasıldı? her elemanı iki değişkenden oluşmaktadır.
user.items() [(name, Daniel), [(surname, Smith)], ...
burada name, daniel 1.eleman, surname, smith 2.eleman.... gidebilir. aşağıdaki örneğe bakalım.

---


"""

test= [(1,2), (3,4), (5,6)]
for i, j in test :  #burada iki değişkenli 3 elemanlı bir liste tanımladık, listenin içindeki 1.elemanı(1,2) her bir değişkene bir paylaştırdı. i=1, j=2 
     print(i, j)

test2 = [(1,2,11), (3,4,22), (5,6,33)]
for i, j, t in test2 :  #burada 3 değişkenli 3 elemanı bir liste tanımladık, listenin içindeki 1.elemanı(1,2,11) her bir değişkene bir paylaştırdı. i=1, j=2, t=11 
     print(i, j, t)   #virgüllerler ayrılmış değerleri (1,2,11) virgüllere ayrılmış değişkenlere(i, j, t) atadık.

#üç elemanlır bir şeyi tek değişkene atayalım.
#buradaki her iterasasyonda test2 nin yani iterable in bir elemanı i değişkenine gelir ve tuple olarak çıkar. bu iterasyon elemanları bitene kadar devam eder.
#test2 nin ilk elemanı tuple içinde (1,2,11) i değişkenine atanır. i = (1,2,11)
#yani bir tane colletion ı (tuple) bir tane değişkene esaymınt (assign) ediyoruz.

for i in test2 :
     print(i)

#first
user = {
    "name": "Daniel",
    "surname": "Smith",
    "age": 35
}
for attribute in user:
     print(attribute)
#buradaki user bir dictionary dir ve user in tüm key leri tek tek attribute a dağılıyor.

#second
user = {
    "name": "Daniel",
    "surname": "Smith",
    "age": 35
}
for i in user.values():      #dictionary deki çiftler key-value idi. burada direkt user daki value ları istedik. eğer belirtmeseydik, key leri alacaktı.
     print(i, end=" ")

for i in "abc" :
     print("hello")       #for döngüsü içinde kullandığımız değişkeni (İ) o kod bloğu body si (print("hello")) içinde kullanmak zorunda değiliz.
     #burada for döngüsü sayılar üzerinden hareket eder. bir str olan "abc" nin yani str in eleman sayısı 3 old.için 3 kez yazdırır. len=3

#third
user = {
    "name": "Daniel",
    "surname": "Smith",
    "age": 35
}
for key, value in user.items():  #burada key,value (değişken). user.items() [iterable]
     print(key, ":", value)

times = int(input("How many times should I say 'I love You'"))
for i in range(times) :
     print('I love You')

number = int(input("Enter a number between 1-9 :"))
for i in range(11) :   #0-10 arası bir sayı üret.
    print(f"{number} x {i} = {number*i}")     # 5x0=5 in yazımı.

for i in range(1,10) :
     print(str(i) * i)

for i in range(1,10) :
     print(str(i)+" " * i)

list(range(11))

tuple(range(11))

set(range(11))

print(range(11)) #sayıları sırayla yazdırmaz.

print(* range(11)) #sayıları sırayla yazdırır.

print(* range(5,25,2)) # start:5 stop:25 step:2

print(range(11)) #range fonksiyonunda görsellik yok ama her seye çevirmek mümkün ayrıca başında * kullanarak seperasyonda yapabiliyoruz.

print(*('separate'))

print(*range(10,0,-2))

text = ['one', 'two', 'three', 'four', 'five']
numbers = [1, 2, 3, 4, 5]
for x, y in zip(text, numbers) :
    print(x, ':', y)

list('hello')

"""## zipped fonksiyonu kullanmı"""

#zip kod bloğunun memory daki lokasyonunu gösterir.
#range fonksiyonunda olduğu gibi havada bir objecet üretir(on the air)
#bunu range gibi nasıl görünür hale getirebiliriz;
# ilki * ile, ikincisi liste yapabiliriz (yani colletion typesları kullanarak; tuple, list) üçüncü olarak ise for döngüleri ile yapabiliriz.
text = ['one', 'two', 'three', 'four', 'five']
numbers = [1, 2, 3, 4, 5]
zipped = zip(text, numbers)
print(zipped)

print(* zipped)  #tuple tuple birleştirdik.

#normalde listelemesi gerekirken boş liste verdi listelemedi çünkü zip object bir generater oluşturuyor. yani bir iterable.
#bu iterable İTERAT edersek içi boşalıyor bu nedenle tekrar doldurmak gerekiyor.
list(zipped)

#burada yeniden doldurmuş olduk.
zipped = zip(text, numbers)
list(zipped)

#yeniden doldurduk
zipped = zip(text, numbers)
for x, y in zipped :
     print(x, ":", y)

print(* zipped) #yine çalışmıyor çünkü yukarda yine içini boşaltmış olduk.

zipped = zip(text, numbers) #yine doldurduk. şimdi de dictionary çevirmiş olduk.
#zip fonksiyonu ikilidir, bu nedenle çok kolay bir şekilde dictionary e çevirebiliriz.
dict(zipped)

list(range(1,10,2))

list(range(0,10,2))

evens = []     #bir liste oluşturacaksak eğer önce boş liste oluşturmak lazım.
odds = []
for n in range(10) :  # bir for döngüsü kurarken neyi iterate edeceğimiz çok önemli.
     if n % 2 == 0 :  # modulus 2 si tam bölünüyorsa ve bu bölüm sonucu sıfıra eşitse bu sayı çifttir.
       evens.append(n)
     else :
       odds.append(n)
print("evens :", evens)
print("odds :", odds)

#example list: [11, 2, 24, 61, 48, 33 ,3]  bu listeyi kullanarak aşağıdaki çıktıyı alalım.
#example output: The number of even numbers : 3
#                The number of odd nunmbers : 4

numbers = (11, 36, 33, 66, 89, 21, 32, 16, 10)
# bu numbers tüm elemanlarını bir kontrole tabi tutalım.
evens = 0   #counter lar yani sayaçta mutlaka ilk değişkene sıfır atamak gerekiyor saydırmak için.

odds = 0
for i in numbers :
    if i % 2 == 0 : # burada sayaç kurduk, yani modulus 2 nin sonucu 0 ise bunlar çift sayıdır.
       evens += 1  #sonra bu evens her sayma da bir artmasını istedik bu yüzden en başa gidip evens = 0 dedik. bu durumda çift ise çifti arttırır, tek ise teki bir arttırır.
    else :
      odds +=1
print("Evens count : ", evens)
print("Odss count :", odds)

# 0 ile 75 arası sayıları toplatalım.
number = 0
for i in range(1, 75) :
  number += i
print(number)

# 0 -75 arasını toplatırken eğer number += i değilde
# number += 1 yazsaydık ne olurdu.
# number = 0 + 1 
# number = 1 + 2
# number = 3 + 3
# number = 6 + 4
number = 0
for i in range(1, 75) :
  number += 1
print(number)
#burada i değeri range fonksiyonundaki 1-75 arasındaki tüm değerleri sırayla alacak, yani sırasıyla 1,2,3,4 diye devam edecek.
# bu yüzden 1 + 3 + 6 + 10 şeklinde toplar. bu nedenle number += i dedik. burada i yi number her defasında bir arttırarak artmasına kilitlemiş olduk.

condition = (3>1) and (1<1)  #buradaki condition normal ama if bloğunun yanındaki ise string halinde yani if in yanındaki ile bu tanımlananın alakası yok.
# bu nedenle de ilk print i yazdırır. print içindeki ıt works un tanımlanan condition la bir alakası yok.
if 'condition':   # dolu bir string olduğu için truety dir İF İN YANINA DOLU BİR ŞEY GELDİĞİ ZAMAN çalışır.
     print('It works')  # ilk dolu string çalışır.
else:
     print('Something is wrong')

#EŞİT DEĞİL != BU ŞEKİLDE YAZILIR.
condition = (3>1) and (-1<1) # True and True sonuç True. Condition True olunca da if şartı sağlar.
if condition :
     print('It works')
else:
     print('Something is wrong')

condition = (3>1) and (1<1) # True and False sonuç False.Fakat str Condition bununla bir ilgisi yok.
if ['condition'] :# Dolu liste olan 'Condition' True olur şart sağlanır.
     print('It works')
else:
     print('Something is wrong')

condition = (3>1) and (0<1) # True and True sonuç True
if not condition :# Not condition False
     print('It works')
else:
     print('Something is wrong')

"""# **NESTED FOR LOOP**
İÇ İÇE FOR DÖNGÜLERİ
"""

for variable1 in iterable1:
    for variable2 in iterable2:  # bu for döngüsü aslında yukarıda bulunan for döngüsünün girintisi yani dışardakinin kod bloğu yani kod bodysi.
    #yani dışarda bulunan for döngüsünü iterable1 kadar içerde bulunan for döngüsünü iterate edecek.
        body  #bu kod body si ise içerde buluanan for döngüsünün kod bodysi oluyor.

who = ['I am', 'You are']
mood = ['happy', 'confident']
for i in who :
    for ii in mood :
        print(i + ii)

names = ["susan", "tom", "edward"]
mood = ["happy", "sad"]
for i in names :
    for ii in mood :
        print(i + ' is ' + ii)

tuple(range(1,8))  #bu tuple değişkenlere assign edebiliriz yani atayabiliriz. alttaki örnekte olduğu gibi.

mon, tue, wed, thu, fri, sat, sun = tuple(range(1, 8))  #değişkenlere sayısal bir değer atamış olduk.

mon  #tuple kullanarak günleri 1-7 arasındaki sayılara atamış olduk.

[1,2,4] + ["ali", "veli"] #iki listeyi concatenate edip birbirine ekleyebiliriz.
# iki listenin elemanları birbirine eklenip tek bir liste oluşturuldu.

#  a, b = (10, 20, 30, 40) #  bu haliyle hata verir verir alt çizgi kullanarak bu atamayı yaparsak hata vermez.
a, _, b, _ = (10, 20, 30, 40)  #şunun atamasını yaptı bu yönteme placeolder (yer tutucu) deniyor. hafızada bir değişken olark yer işgal etmiyor ve hata vermesine engel oluyor.

a

#place holder da ki avantaj çok çeşitli elemanları olan listelerin içinden indexleme yapmadan eleman çekip almak.
x, y, *z = (11, 22, 33, 44, 55) #burada x ve y 11, 22 olarak atayıp geri kalanları ise z ye atamak istiyorsak eğer:
#z nin önüne * koyup z yi iterable hala getirebiliriz yani seperable (elemanlarına ayrılabilir) hala getirmiş oluruz.

x, y

z

x

x, y, *_ = (11, 22, 33, 44, 55)
_                                #en son hafızada ne varsa onu tutuyor.

x, y, *z, t = (11, 22, 33, 44, 55, 66, 77)  #son elemanı t ye nasıl atarız.

t

x, y, *_, t = (11, 22, 33, 44, 55, 66, 77) #bu işlemlerde veri tipiye ilgili değil, konu atama assign olduğu için str, int, float ... hepsiyle olur.

